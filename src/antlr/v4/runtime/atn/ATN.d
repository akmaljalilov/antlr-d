/*
 * [The "BSD license"]
 *  Copyright (c) 2016 Terence Parr
 *  Copyright (c) 2016 Sam Harwell
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

module antlr.v4.runtime.atn.ATN;

import antlr.v4.runtime.RuleContext;
import antlr.v4.runtime.atn.ATNState;
import antlr.v4.runtime.atn.ATNType;
import antlr.v4.runtime.atn.DecisionState;
import antlr.v4.runtime.atn.RuleStartState;
import antlr.v4.runtime.atn.LL1Analyzer;
import antlr.v4.runtime.atn.TokensStartState;
import antlr.v4.runtime.atn.LexerAction;
import antlr.v4.runtime.misc.IntervalSet;

// Class ATN
/**
 * Class implementation adapted from Java code
 */
class ATN
{

    public static immutable int INVALID_ALT_NUMBER = 0;

    public ATNState[] states;

    /**
     * @uml
     * Each subrule/rule is a decision point and we must track them so we
     * can go back later and build DFA predictors for them.  This includes
     * all the rules, subrules, optional blocks, ()+, ()* etc...
     */
    public DecisionState[] decisionToState;

    /**
     * @uml
     * Maps from rule index to starting state number.
     */
    public RuleStartState[] ruleToStartState;

    /**
     * @uml
     * Maps from rule index to stop state number.
     */
    public RuleStartState[] ruleToStopState;

    public TokensStartState[string] modeNameToStartState;

    /**
     * @uml
     * The type of the ATN.
     */
    public ATNType grammarType;

    /**
     * @uml
     * The maximum value for any symbol recognized by a transition in the ATN.
     */
    public int maxTokenType;

    /**
     * @uml
     * For lexer ATNs, this maps the rule index to the resulting token type.
     * For parser ATNs, this maps the rule index to the generated bypass token
     * type if the
     * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}
     * deserialization option was specified; otherwise, this is {@code null}.
     */
    public int[] ruleToTokenType;

    /**
     * @uml
     * For lexer ATNs, this is an array of {@link LexerAction} objects which may
     * be referenced by action transitions in the ATN.
     */
    public LexerAction[] lexerActions;

    public TokensStartState modeToStartState;

    /**
     * @uml
     * Used for runtime deserialization of ATNs from strings
     */
    public this(ATNType grammarType, int maxTokenType)
    {
        this.grammarType = grammarType;
        this.maxTokenType = maxTokenType;
    }

    /**
     * @uml
     * Compute the set of valid tokens that can occur starting in state {@code s}.
     * If {@code ctx} is null, the set of tokens will not include what can follow
     * the rule surrounding {@code s}. In other words, the set will be
     * restricted to tokens reachable staying within {@code s}'s rule.
     */
    public IntervalSet nextTokens(ATNState s, RuleContext ctx)
    {
        LL1Analyzer anal = new LL1Analyzer(this);
        IntervalSet next = anal.LOOK(s, ctx);
        return next;
    }

}
